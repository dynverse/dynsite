---
title: "Preparing the data"
output:
  blogdown::html_page:
    toc: true
weight: 1
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, results="hold")
```

```{r, results='hide', message=FALSE, warning=FALSE}
library(dyno)
library(tidyverse)
```

The main functions to wrap a dataset are included within the [dynwrap](/reference/dynwrap) package.

## Gene expression data

As input, dynwrap requires raw counts and normalised (log2) expression data. Cells with low expression, doublets and other "bad" cells should already be filtered from this matrix. Features (i.e. genes) may already be filtered, but this is not required. Some methods internally include a feature filtering step, while others can handle a lot of features just fine.

Internally, dynwrap works with a sparse matrix (`dgCMatrix`) which reduces the memory footprint.

```{r}
dataset <- wrap_expression(
  expression = example_dataset$expression,
  counts = example_dataset$counts
)
```

## Prior information

Some methods require prior information to be specified. You can add this prior information to the dataset using `dynwrap::add_prior_information`:

```{r}
dataset <- add_prior_information(
  dataset,
  start_id = "Cell1"
)
```

## Optional information

### Grouping / clustering

You can add a grouping or clustering to the data using `dynwrap::add_grouping`:

```{r}
# dataset <- add_grouping(
#   dataset,
#   example_dataset$grouping
# )
```

### Dimensionality reduction

You can add a grouping or clustering to the data using `dynwrap::add_dimred`. The dimensionality reduction should be a matrix with the same rownames as the original expression matrix.

```{r}
dataset <- add_dimred(
  dataset,
  example_dataset$dimred
)
```

## Current limitations

Currently, alternative input data such as ATAC-Seq or cytometry data are not yet supported, although it is possible to simply include this data as expression and counts.

In the near future, we will also add the ability to include [RNA velocity](https://www.nature.com/articles/s41586-018-0414-6) as input. See the discussion at https://github.com/dynverse/dynwrap/issues/112

# Selecting the best methods for a dataset

Within [our evaluation study](https://doi.org/10.1038/s41587-019-0071-9), we compared 45 methods on four aspects:

* **Accuracy**: How similar is the inferred trajectory to the "true" (or "expected") trajectory in the data. We used several metrics for this, comparing the cellular ordering and topology, and compared against both real datasets, for which a gold standard is not always so well defined, and synthetic data, which are not necessarily as biologically relevant as real data.
* **Scalability**: How long the method takes to run and how much memory it consumes. This mainly depends on the dimensions of the input data, i.e. the number of cells and features.
* **Stability**: How stable the results are when rerunning the method with different seeds or slightly different input data.
* **Usability**: The quality of the documentation and tutorials, how easy it is to run the method, whether the method is well tested, ... We created a transparent scoresheet to assess each of these aspects in a _more or less_ objective way.

Perhaps not surprisingly, we found a high diversity in method performance, and that not many methods perform well across the board. The performance of a method depended on many factors, mainly the dimensions of the data and the kind of trajectory present in the data. Based on this, we developed an interactive shiny app which you can use to explore the results and select an optimal set of methods for your analysis.

This app can be opened using `dynguidelines::guidelines_shiny()`. It is recommended to give this function your dataset, so that it will precalculate some fields for you:

```r
dataset <- example_dataset
guidelines_shiny(dataset = dataset)
```

The app includes a tutorial, which will guide you through the user interface. Once finished, it is highly recommended to copy over the code that generates the guidelines to your script, so that your analysis remains reproducible, for example:

```{r}
dataset <- example_dataset
guidelines <- guidelines(
  dataset,
  answers = answer_questions(
    dataset,
    multiple_disconnected = FALSE,
    expect_topology = TRUE,
    expected_topology = "linear"
  )
)
```

This guidelines object contains:

- Information on the selected methods: `guidelines$methods`
- The names of the selected methods: `guidelines$methods_selected`
- The answers given in the app (or their defaults): `guidelines$answers`
